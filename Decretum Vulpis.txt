0) Все вносимые на git изменения обязаны быть проверены (т.е. не должны ломать уже созданное, а
так же не должны вызывать багов)
0') В случае обнаружения поломки или бага после залития на гит, "вредитель" обязан в течение 12-ти часов с момента обнаружения
исправить данную поломку/баг

1. Для страниц:
1.0) Глава=ная страница должна называться main.html
1.1) Шаблоны страниц (файлы с расширением .pug) кладутся в папку views
1.2) Страницы (файлы с расширением .реьд) кладутся в папку public/html/

1.3) Среди шаблонов и страниц не должны совпадать имена (иначе будут загружаться только шаблоны)

1.4) Для каждой страницы (т.е. каждого файла страницы, будь то .pug или .html) в папке /public/scripts/ должен 
быть создан скрипт с соответствующим именем
	Пример:	для страницы "main.html" будет соответствовать файл "main.js"
			для страницы "test.pug"  будет соответствовать файл "test.js"

1.5) В <head> должны быть прописаны строчки:
	  <script type="text/javascript" src= "/public/scripts/jquery.js"></script>
	  <script type="text/javascript" src= "/public/scripts/ajax.js"></script>
	  <script type="text/javascript" src= "/public/scripts/<name_of_page>.js"></script>
	  
	они нужны для общения с сервером
	<name_of_page> - название скриптового файла страницы
	
	(в .pug условия те же, только они чуть иначе будут писаться в соответствие с синтаксисом самого pug'а)
	
1.6) Интерактивные элементы:
	а) у всех элементов ввода должен быть id. id должен быть осмысленным названием аргумента 
	(ибо потом это название будет использоваться при составлении запросов)
	Пример: элемент ввода названия факультета должен приблизительно быть похож название
		<input id="nameFacultet" ...> 
		сдесь троеточие означает другие параметры (на вроде класса, типа вводимых данных...)
		
	б) Кнопки могут быть 2-х типов:
		- отправка запроса/вызова интерактивных меню: <button onclick="name_of_function()">Текст на кнопке</button>
		сдесь name_of_function() - функция начала тправки запроса (главное - onclick="name_of_function()" )
		- перехода на другую страницу: <a href="/"><button>Текст на кнопке</button></a>
		сдесь вожно href="/" (вместо "/" может стоять название другой страницы)
		
	в) форма для импорта базы данных, предсавленная в файле import.html, в скорем времени может измениться (в связи с
	исправлением одного бага)
	
2. Для скриптов страниц:
2.0) Перед названием каждой функции должен быть коментарий о том, что эта функция делает
2.1) Для каждой кнопки запроса должны быть созданы (в обязательном порядке 2 функции):
2.1.1) Функция, вызываемая при нажатии на кнопку (см. 1.6.б, "отправка запроса") должна:
	- называться response<Название_запроса>
	- содержать следующий код:
		ajax<Тип ajax запроса*>(
			"/<название запроса>", 
			{
				<имя аргумента_1>: $("#<имя аргумента_1>".val),
				...
				<имя аргумента_n>: $("#<имя аргумента_n>".val)
			},
			request<Название_запроса>
		);
	имя аргумента аналогичто п. 1.6.а
	
2.1.2) Должна быть создана функция вида 
	request<Тип ajax запроса*>(req){...}
в которой будет содержаться код, отвечающий за вывод ответа сервера
(данная функция может ничего не делать)

*Типы ajax запросов и их назначение:
	- Put    - обновление или добавление записей в БД
	- Get    – получение записи (записей) из БД
	- Post   – добавление записи (так же желательно его использовать для получения записей вместо Get)
	- Delete - удаление записей из БД (внимание - может не работать -> тогда для удаления используем Post либо Put)
	
	
3. Работа с сервером (bin/rout.js):
3.0) В данном файле находятся "ловушки" на все запросы от клиента (от страницы в браузере)
3.1) Для каждого шаблона, предполагающего использование какой-либо посторонней информации
в подразделе "Шаблоны" раздела "//Базовая адресация" должен быть создан соответствующий обработчик
Пример:
	router.get("/test", (req, res) =>{
		db.doTest(res, req.body, (res, ans)=>{res.render("test",{strs: ans});});
	});

где "/test" - адрес, по которому отображается страница
doTest - запрос, дающий информацию по запросу Test (подробнее см. п.4)
"test" - название pug страницы
strs - так будет называться объект данных в pug файле


3.2) Для каждого запроса (см. п. 2.1) должен быть создан соответствующий обработчик 
в разделе "//Обработчики запросов клиентов"
Обработчик должен иметь вид:
	router.<Тип ajax запроса**>("/<название запроса>", (req,res) => {
		db.do<Название запроса>(res, req.body, <func>);
	});
<func> - функция-ответ сервера (генерит ответ сервера. По умолчанию
лучше использовать classicEnd - она отправлят сформированный json клиенту)
	
** Типы соответствуют таковым из п.3, но пишутся маленькими буквами (в п.3 - первая - заглавная)


4. Работа с прослойкой (bin/db.js):
4.0) Этот файл служит прослойкой между "сервером" и "базой данных" - "посылает" запрос к neo4j, а
	затем разбирает ответ (приводит к читаемому виду)
4.1) Для каждого запроса необходимо создать обработчик вида:
do<Запрос>(res, params, end){
	rq.<запрос>(
		res,
		(res,result)=>{end(res, this.<func>);},
		params
	);
}
где: <func> - функция, отвечающая за перевод ответа от neo4j в адекватный вид (подробнее - п.4.2)

4.2) Для каждого запроса должен быть создан переводчик (исключение - п.4.3):
parse<>(result), возвращающий json

4.3) Не обязательно создавать переводчик для "классического" вида запросов	
	(не содержит вызова id(), cost(),...): для этого уже создан parseClassic
	(в результате ответ будет выглядеть как массив массивов аргументов:
	[["FKTI","Primat","6383"],["FKTI","Primat","6382"]]

 
5. Работа с базой данных neo4j  (bin/requests.js):

5.1) Для каждого запроса должен быть создан "отправлятор" вида:
<запрос>(res, func = this.standartFinal, params = {}){
	this.doRequest(
		`<запрос Cypher-Shell>`,
		res,
		func
	);
}

<запрос Cypher-Shell> - строка, содержащая запрос на языке Cypher-Shell...
если что - параметры для запроса находятся в params:
например, запрос показывающий всех студентов гр. 6383 будет выглядеть как:
`MATCH(G:Group)--(S:Student) WHERE G.num=${params.num} RETURN S.Lastname, S.Firstname;`


